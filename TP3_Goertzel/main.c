#include "dsk6713_aic23.h"

Uint32 input_left_sample();
void output_left_sample(int out_data);
void comm_intr();

#define 	N 			192
#define 	CONTRASTE 	8
#define 	TIME_5sec 	2500 	// 5*Fe/N = 2500
#define 	TIME_10ms 	960 	// 0.010 * Fe = 960
#define 	TIME_1sec 	96000 	// 1 * Fe = 96000

short XnBufferExcel[N] = // Table Sinus de fréquence 22 KHz
{0,32488,8481,-30274,-16384,25997,23170,-19948,-28378,12540,31651,-4277,-32768,-4277,31651,12540,
-28378,-19948,23170,25997,-16384,-30274,8481,32488,0,-32488,-8481,30274,16384,-25997,-23170,19948,
28378,-12540,-31651,4277,32767,4277,-31651,-12540,28378,19948,-23170,-25997,16384,30274,-8481,-32488,
0,32488,8481,-30274,-16384,25997,23170,-19948,-28378,12540,31651,-4277,-32768,-4277,31651,12540,
-28378,-19948,23170,25997,-16384,-30274,8481,32488,0,-32488,-8481,30274,16384,-25997,-23170,19948,
28378,-12540,-31651,4277,32767,4277,-31651,-12540,28378,19948,-23170,-25997,16384,30274,-8481,-32488,
0,32488,8481,-30274,-16384,25997,23170,-19948,-28378,12540,31651,-4277,-32768,-4277,31651,12540,
-28378,-19948,23170,25997,-16384,-30274,8481,32488,0,-32488,-8481,30274,16384,-25997,-23170,19948,
28378,-12540,-31651,4277,32767,4277,-31651,-12540,28378,19948,-23170,-25997,16384,30274,-8481,-32488,
0,32488,8481,-30274,-16384,25997,23170,-19948,-28378,12540,31651,-4277,-32768,-4277,31651,12540,
-28378,-19948,23170,25997,-16384,-30274,8481,32488,0,-32488,-8481,30274,16384,-25997,-23170,19948,
28378,-12540,-31651,4277,32767,4277,-31651,-12540,28378,19948,-23170,-25997,16384,30274,-8481,-32488 };

short Coeff[8] = {23085, 21066, 19024, 16962, 14882, 12785, 10676, 8554};

short TabSinus1Hz[N] =
{16384,16375,16349,16305,16244,16165,16069,15956,15826,15679,15515,15334,15137,14924,14694,14449,
14189,13913,13623,13318,12998,12665,12318,11958,11585,11200,10803,10394,9974,9543,9102,8652,
8192,7723,7246,6762,6270,5771,5266,4756,4240,3720,3196,2669,2139,1606,1072,536,
0,-536,-1072,-1606,-2139,-2669,-3196,-3720,-4240,-4756,-5266,-5771,-6270,-6762,-7246,-7723,
-8192,-8652,-9102,-9543,-9974,-10394,-10803,-11200,-11585,-11958,-12318,-12665,-12998,-13318,-13623,-13913,
-14189,-14449,-14694,-14924,-15137,-15334,-15515,-15679,-15826,-15956,-16069,-16165,-16244,-16305,-16349,-16375,
-16384,-16375,-16349,-16305,-16244,-16165,-16069,-15956,-15826,-15679,-15515,-15334,-15137,-14924,-14694,-14449,
-14189,-13913,-13623,-13318,-12998,-12665,-12318,-11958,-11585,-11200,-10803,-10394,-9974,-9543,-9102,-8652,
-8192,-7723,-7246,-6762,-6270,-5771,-5266,-4756,-4240,-3720,-3196,-2669,-2139,-1606,-1072,-536,
0,536,1072,1606,2139,2669,3196,3720,4240,4756,5266,5771,6270,6762,7246,7723,
8192,8652,9102,9543,9974,10394,10803,11200,11585,11958,12318,12665,12998,13318,13623,13913,
14189,14449,14694,14924,15137,15334,15515,15679,15826,15956,16069,16165,16244,16305,16349,16375};

Uint32 fs = DSK6713_AIC23_FREQ_96KHZ;

short Qn[8], Qn_1[8], Qn_2[8];
Uint32 Module[8], ModuleMax = 0, ModuleMaxSuivant = 0, n;
short Xn, XnBuffer[N];
Uint16 i, j, f, fmax, Canal_Libre, Canal_Trouve, STEP, cpt5sec = 0, Tab_Detection[8];
int tmp1;
short tmp2;


interrupt void c_int11()
{
	if(Canal_Trouve == 0){
		if(cpt5sec < TIME_5sec){
			Xn = XnBufferExcel[i];
			XnBuffer[i] = Xn;

			for(f = 0; f < 8; f++){
				//Qn(f) = Xn + Coeff(f) * Qn_1(f) – Qn_2(f)		// Calcul en virgule fixe
				tmp1 = (int) (Xn << 8) + (int) (Coeff[f] * Qn_1[f]) - (int) (Qn_2[f] << 15);
				Qn[f] = (short) (tmp1 >> 15);					// Qn[f] = Q23 >> 15 = Q8

				Qn_2[f] = Qn_1[f];
				Qn_1[f] = Qn[f];
			}

			i = (i + 1) % N;
			if(i == 0){
				cpt5sec++;
				for(f = 0; f < 8; f++){
					//Module(f) = Qn_1(f) * Qn_1(f) + Qn_2(f) * Qn_2(f) – Qn_1(f) * Qn_2(f) * Coeff(f)
					Module[f] = (Uint32) (Qn_1[f] * Qn_1[f]) + (Uint32) (Qn_2[f] * Qn_2[f]);

					tmp2 = (short) ((Qn_1[f] * Coeff[f]) >> 15);	// tmp2 = (Q8(16) * Q15(16)) >> 15 = Q8(16)
					tmp1 = (int) (tmp2 * Qn_2[f]);					// tmp1 = Q8(16) * Q8(16) = Q16(32)
					Module[f] = (Uint32) (Module[f] - tmp1);		// Module = Q16(32) - Q16(32) = Q16(32)

					if(Module[f] > ModuleMax){
						ModuleMax = Module[f];
						fmax = f;
					}
				}

				for(f = 0; f < 8; f++){
					if( (Module[f] != ModuleMax) && (Module[f] > ModuleMaxSuivant)){
						ModuleMaxSuivant = Module[f];
						Qn_1[f] = 0;	Qn_2[f] = 0;
					}
				}

				if(ModuleMax > (ModuleMaxSuivant * CONTRASTE))	Tab_Detection[fmax] = 1;
			}
			ModuleMax = 0;
			ModuleMaxSuivant = 0;
			output_left_sample(0);
		}
		else {
			for(f = 0; f < 8; f++){
				if(Tab_Detection[f] == 0){
					Canal_Libre = f;
					STEP = f + 37;
					Canal_Trouve = 1;
					n = 0;
					i = 0;
					j = 0;
					output_left_sample(0);
				}
			}
		}
	}
	else {
		if(n < TIME_10ms){
			Xn = TabSinus1Hz[j];
			output_left_sample(Xn);
			i = (i + 1) % N;
			j = (i * STEP) % N;
		}
		else {
			i = 0;
			j = 0;
			output_left_sample(0);
		}
		n = (n + 1) % TIME_1sec;
	}
	return;
}

main()
{
	i = 0;
	cpt5sec = 0;
	ModuleMax = 0;
	ModuleMaxSuivant = 0;
	Canal_Trouve = 0;

	for(f = 0; f < 8; f++){
		Qn[f] = 0;	Qn_1[f] = 0;	Qn_2[f] = 0;	Module[f] = 0;	Tab_Detection[f] = 0;
	}

	comm_intr();
	while(1);
}



